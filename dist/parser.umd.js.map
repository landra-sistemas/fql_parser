{"version":3,"file":"parser.umd.js","sources":["../src/FQLParser.mjs","../src/sql/SQLParser.mjs","../src/sql/KnexParser.mjs"],"sourcesContent":["import XRegExp from \"xregexp\";\nimport lodash from \"lodash\";\n\nexport default class FQLParser {\n\n    LIKE = \"LIKE\";\n\n    constructor(options) {\n        this.aliases = (options && options.aliases) || {};\n        this.allowGlobalSearch = (options && options.allowGlobalSearch) || false;\n\n        if (options && options.caseInsensitive) {\n            this.LIKE = \"ILIKE\";\n        }\n    }\n    /**\n     * Convierte un string 'key:value' en array de objetos con las siguientes opciones:\n     * \n     * - Objeto: { //Condición Básica\n     *  \"key\": \"\",\n     *  \"operator\": \"LIKE|NOT LIKE|>|<|BETWEEN\", //Default LIKE\n     *  \"value\": \"\",\n     *  \"logic\": \"OR|AND\" //Default AND\n     * }\n     * \n     * - Array: Agrupación de condiciones, extraída de un (). Dentro del array llevará otros array o objetos condición\n     * \n     * @param {*} str \n     * @returns \n     */\n    parse = (str) => {\n        let parsedElm = [];\n        let workStr = str;\n        const parentheses = this.splitPatentheses(str);\n\n        if (!lodash.isEmpty(parentheses)) {\n            for (const elm in parentheses) {\n                //Reemplazar el la query original cada elemento\n                workStr = workStr.replace(`${parentheses[elm]}`, `#${elm}`);\n                parsedElm.push(this.parse(parentheses[elm]));\n            }\n\n        }\n        // console.log(workStr);\n\n        return this.parseQS(workStr, parsedElm);\n\n    }\n\n\n    /**\n     * Extrae los bloques entre parentesis (solo un nivel).\n     * \n     * @param {*} str \n     * @returns \n     */\n    splitPatentheses = (str) => {\n        const test = XRegExp.matchRecursive(str, '\\\\(', '\\\\)', 'g');\n        return test;\n    }\n\n\n    /**\n     * Aplica una expresión regular para extraer los parámetros de búsqueda:\n     * - key: columna\n     * - operator: operador búsqueda\n     * - value: valor a buscar\n     * - logic: operador logico a utilizar\n     * - plain: parametro plano adicional (ejemplo +test o -asdfasdf). Necesario activar allowGlobalSearch\n     * @param {*} str \n     * @param {*} subgroups \n     * @returns \n     */\n    parseQS = (str, subgroups) => {\n        const regex = /((?<key>[^\\s|^:|^!:|^>:|^<:]+)(?<operator>:|!:|>:|<:)(?<value>[^\\s|\"|\\[]+|\".*?\"|\\[.*?\\]))? ?(?<logic>OR|AND)? ?(?<plain>[\\+|\\-|\\(#][^\\s]+|)? ?/gm;\n        let m;\n\n        let data = [];\n        while ((m = regex.exec(str)) !== null) {\n            // This is necessary to avoid infinite loops with zero-width matches\n            if (m.index === regex.lastIndex) {\n                regex.lastIndex++;\n            }\n            if (m === null) {\n                continue;\n            }\n            let { key, value, operator, plain, logic } = m.groups;\n\n            if (!operator) {\n                operator = \":\";\n            }\n\n            let type = this.LIKE;\n            switch (operator) {\n                case \":\":\n                default:\n                    type = this.LIKE;\n                    break;\n                case \"!:\":\n                    type = `NOT ${this.LIKE}`;\n                    break;\n                case \">:\":\n                    type = \">\";\n                    break;\n                case \"<:\":\n                    type = \"<\";\n                    break;\n            }\n            //Los corchetes marcan rangos con lo que si se detecta se cambia el tipo LIKE a BETWEEN\n            if (value && value.match(/\\[.*?TO.*?\\]/)) {\n                type = type === `NOT ${this.LIKE}` ? \"NOT BETWEEN\" : \"BETWEEN\";\n            }\n            //Las comas implican varios valores con lo que si se detectan se cambia el tipo LIKE a IN\n            if (value && value.indexOf(',') !== -1) {\n                type = type === `NOT ${this.LIKE}` ? \"NOT IN\" : \"IN\";\n            }\n\n            if (key) {\n                data.push({\n                    key: this.checkAliases(key),\n                    operator: type,\n                    value: this.parseValue(value),\n                    logic: logic || \"AND\"\n                });\n            }\n            // Gestion para añadir los indices de los subgrupos\n            if (plain && plain.indexOf('#') !== -1) {\n                const index = plain.replace(/#|\\(|\\)/g, '');\n                data.push(subgroups[parseInt(index)]);\n            } else if (this.allowGlobalSearch && plain && plain.indexOf('#') === -1) {\n                // Añadir las busquedas plain en caso de estar activadas.\n                let op = \"plain_+\";\n                if (plain.startsWith('-')) {\n                    op = \"plain_-\";\n                }\n                data.push({\n                    operator: op,\n                    value: this.parseValueForPlainQuery(plain.replace(/\\+|\\-/gm, '')),\n                    logic: logic || \"AND\"\n                });\n            }\n        }\n        return data;\n    }\n\n\n\n    /**\n     * \n     * @param key \n     * @returns \n     */\n    checkAliases(key) {\n        if (!this.aliases) {\n            return key;\n        }\n        if (this.aliases[key]) {\n            return this.aliases[key].replaceAll(\"{{key}}\", key);\n        }\n        if (this.aliases['*']) {\n            return this.aliases['*'].replaceAll(\"{{key}}\", key);\n        }\n        return key;\n    }\n\n    /**\n     * \n     * @param value \n     * @returns \n     */\n    parseValue(value) {\n        //TODO improve\n        return value.replaceAll(/\"|\\?/g, '').replaceAll('*', '%');\n    }\n    /**\n     * \n     * @param value \n     * @returns \n     */\n    parseValueForPlainQuery(value) {\n        //TODO improve\n\n        const wildcard = value.includes(\"*\") ? \":*\" : \"\";\n        return value.replaceAll(/\"|\\?/g, '').replaceAll('*', wildcard);\n    }\n}\n","export default class SQLParser {\n\n    constructor(table, dialect = \"pg\") {\n        this.table = table;\n        this.dialect = dialect;\n    }\n\n    /**\n     * Converte una lista de condiciones generada por el FQLParser en una condición String.\n     * \n     * Esta clase sirve como base para su extensión aplicando las conversiones necesarias en función del lenguaje a utilizar.\n     * \n     * @param {Array} object\n     */\n    parse(object) {\n        let query = \"\";\n        let bindings = [];\n        for (let element of object) {\n            if (Array.isArray(element)) {\n                const { query: subqry, bindings: subbind } = this.parse(element);\n                query += `(${subqry})`;\n                bindings = [...bindings, ...subbind];\n            } else if (typeof element === 'object') {\n                const { query: condition, bindings: bind } = this.convertCondition(element);\n                query += condition;\n                bindings = [...bindings, ...bind];\n            } else {\n                console.warn('Unknown type detected in qry');\n            }\n        }\n        query = query.replace(/( AND | OR )$/gm, \"\");\n        return { query, bindings }; //Quitar condicion final\n    }\n\n    /**\n     * Metodo base a ser extendido por los parsers para realizar las conversiones\n     * \n     * @param {object} condition \n     */\n    convertCondition(condition) {\n        let { key, operator, value, logic } = condition;\n        if (!key) {\n            if (this.dialect !== \"pg\") {\n                console.warn('Only PostgreSQL supports global searching');\n                return \"\";\n            }\n\n            let op = \"\";\n            if (operator === \"plain_-\") {\n                op = \"NOT\";\n            }\n            return { query: `${op} to_tsvector(${this.table}::text) @@ to_tsquery(?) ${logic} `, bindings: [value] }\n        }\n\n\n        let binding = \"?\";\n        let parsedValue = [value]; //Eliminar las dobles comillas\n\n        if (operator === \"BETWEEN\" || operator === \"NOT BETWEEN\") {\n            parsedValue = value.replace(/\\[|\\]/gm, '');\n            parsedValue = parsedValue.split(' TO ');\n            binding = \"? AND ?\";\n        }\n        if (operator === \"IN\" || operator === \"NOT IN\") {\n            parsedValue = [value.split(',')];\n        }\n\n        return { query: `${key} ${operator} ${binding} ${logic} `, bindings: parsedValue }\n    }\n\n\n}","import SQLParser from \"./SQLParser.mjs\";\n\nexport default class KnexParser extends SQLParser {\n\n    /**\n     * \n     * @param {Knex} builder \n     * @param {object} object \n     */\n    toKnex(builder, object) {\n        const parsed = this.parse(object);\n        return builder.whereRaw(parsed.query, parsed.bindings);\n    }\n}"],"names":["FQLParser","options","_this","this","LIKE","parse","str","parsedElm","workStr","parentheses","splitPatentheses","lodash","isEmpty","elm","replace","push","parseQS","XRegExp","matchRecursive","subgroups","m","regex","_wrapRegExp","key","operator","value","logic","plain","data","exec","index","lastIndex","_m$groups","groups","type","match","indexOf","checkAliases","parseValue","parseInt","allowGlobalSearch","op","startsWith","parseValueForPlainQuery","aliases","caseInsensitive","_proto","prototype","replaceAll","wildcard","includes","SQLParser","table","dialect","object","_step","query","bindings","_iterator","_createForOfIteratorHelperLoose","done","element","Array","isArray","_this$parse","concat","_this$convertConditio","convertCondition","console","warn","condition","binding","parsedValue","split","KnexParser","_SQLParser","apply","arguments","toKnex","builder","parsed","whereRaw"],"mappings":"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"}