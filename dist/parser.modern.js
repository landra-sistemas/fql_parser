import e from"xregexp";import t from"lodash";import"knex";function r(){r=function(e,t){return new l(e,void 0,t)};var e=RegExp.prototype,t=new WeakMap;function l(e,r,n){var s=new RegExp(e,r);return t.set(s,n||t.get(e)),o(s,l.prototype)}function s(e,r){var n=t.get(r);return Object.keys(n).reduce(function(t,r){return t[r]=e[n[r]],t},Object.create(null))}return n(l,RegExp),l.prototype.exec=function(t){var r=e.exec.call(this,t);return r&&(r.groups=s(r,this)),r},l.prototype[Symbol.replace]=function(r,n){if("string"==typeof n){var o=t.get(this);return e[Symbol.replace].call(this,r,n.replace(/\$<([^>]+)>/g,function(e,t){return"$"+o[t]}))}if("function"==typeof n){var l=this;return e[Symbol.replace].call(this,r,function(){var e=arguments;return"object"!=typeof e[e.length-1]&&(e=[].slice.call(e)).push(s(e,l)),n.apply(this,e)})}return e[Symbol.replace].call(this,r,n)},r.apply(this,arguments)}function n(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&o(e,t)}function o(e,t){return o=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},o(e,t)}class l{constructor(n){this.parse=e=>{let r=[],n=e;const o=this.splitPatentheses(e);if(!t.isEmpty(o))for(const e in o)n=n.replace(`${o[e]}`,`#${e}`),r.push(this.parse(o[e]));return console.log(n),this.parseQS(n,r)},this.splitPatentheses=t=>e.matchRecursive(t,"\\(","\\)","g"),this.parseQS=(e,t)=>{const n=/*#__PURE__*/r(/(([^\s|^:|^!:|^>:|^<:]+)(:|!:|>:|<:)([^\s|"|\[]+|".*?"|\[.*?\]))? ?(OR|AND)? ?([\+|\-|\(#][^\s]+|)? ?/gm,{key:2,operator:3,value:4,logic:5,plain:6});let o,l=[];for(;null!==(o=n.exec(e));){if(o.index===n.lastIndex&&n.lastIndex++,null===o)continue;let{key:e,value:r,operator:s,plain:i,logic:a}=o.groups;s||(s=":");let c="LIKE";switch(s){case":":default:c="LIKE";break;case"!:":c="NOT LIKE";break;case">:":c=">";break;case"<:":c="<"}if(r&&r.match(/\[.*?\]/)&&(c="NOT LIKE"===c?"NOT BETWEEN":"BETWEEN"),r&&-1!==r.indexOf(",")&&(c="NOT LIKE"===c?"NOT IN":"IN"),e&&l.push({key:e,operator:c,value:r,logic:a||"AND"}),i&&-1!==i.indexOf("#")){const e=i.replace(/#|\(|\)/g,"");l.push(t[parseInt(e)])}else if(this.allowGlobalSearch&&i&&-1===i.indexOf("#")){let e="plain_+";i.startsWith("-")&&(e="plain_-"),l.push({operator:e,value:i.replace(/\+|\-/gm,""),logic:a||"AND"})}}return l},this.columns=n&&n.columns||[],this.allowGlobalSearch=n&&n.allowGlobalSearch||!1}}class s{parse(e){let t="",r=[];for(let n of e)if(Array.isArray(n)){const{query:e,bindings:o}=this.parse(n);t+=`(${e})`,r=[...r,...o]}else if("object"==typeof n){const{query:e,bindings:o}=this.convertCondition(n);t+=e,r=[...r,...o]}else console.warn("Unknown type detected in qry");return t=t.replace(/( AND | OR )$/gm,""),{query:t,bindings:r}}convertCondition(e){if(!e.key)return console.warn("PlainSQL doest not support global searching"),"";let{key:t,operator:r,value:n,logic:o}=e,l="?",s=[n.replaceAll('"',"")];return"BETWEEN"!==r&&"NOT BETWEEN"!==r||(s=n.replace(/\[|\]/gm,""),s=s.split(" TO "),l="? AND ?"),"IN"!==r&&"NOT IN"!==r||(s=[n.split(",")]),{query:`${t} ${r} ${l} ${o} `,bindings:s}}}class i extends s{toKnex(e,t){const r=this.parse(t);return e.whereRaw(r.query,r.bindings)}}export{l as FQLParser,i as KnexParser,s as SQLParser};
//# sourceMappingURL=parser.modern.js.map
