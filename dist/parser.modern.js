import e from"xregexp";import t from"lodash";function r(){r=function(e,t){return new i(e,void 0,t)};var e=RegExp.prototype,t=new WeakMap;function i(e,r,s){var o=new RegExp(e,r);return t.set(o,s||t.get(e)),n(o,i.prototype)}function o(e,r){var s=t.get(r);return Object.keys(s).reduce(function(t,r){return t[r]=e[s[r]],t},Object.create(null))}return s(i,RegExp),i.prototype.exec=function(t){var r=e.exec.call(this,t);return r&&(r.groups=o(r,this)),r},i.prototype[Symbol.replace]=function(r,s){if("string"==typeof s){var n=t.get(this);return e[Symbol.replace].call(this,r,s.replace(/\$<([^>]+)>/g,function(e,t){return"$"+n[t]}))}if("function"==typeof s){var i=this;return e[Symbol.replace].call(this,r,function(){var e=arguments;return"object"!=typeof e[e.length-1]&&(e=[].slice.call(e)).push(o(e,i)),s.apply(this,e)})}return e[Symbol.replace].call(this,r,s)},r.apply(this,arguments)}function s(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&n(e,t)}function n(e,t){return n=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},n(e,t)}class i{constructor(s){this.parse=e=>{let r=[],s=e;const n=this.splitPatentheses(e);if(!t.isEmpty(n))for(const e in n)s=s.replace(`${n[e]}`,`#${e}`),r.push(this.parse(n[e]));return console.log(s),this.parseQS(s,r)},this.splitPatentheses=t=>e.matchRecursive(t,"\\(","\\)","g"),this.parseQS=(e,t)=>{const s=/*#__PURE__*/r(/(([^\s|^:|^!:|^>:|^<:]+)(:|!:|>:|<:)([^\s|"|\[]+|".*?"|\[.*?\]))? ?(OR|AND)? ?([\+|\-|\(#][^\s]+|)? ?/gm,{key:2,operator:3,value:4,logic:5,plain:6});let n,i=[];for(;null!==(n=s.exec(e));){if(n.index===s.lastIndex&&s.lastIndex++,null===n)continue;let{key:e,value:r,operator:o,plain:l,logic:a}=n.groups;o||(o=":");let c="LIKE";switch(o){case":":default:c="LIKE";break;case"!:":c="NOT LIKE";break;case">:":c=">";break;case"<:":c="<"}if(r&&r.match(/\[.*?\]/)&&(c="NOT LIKE"===c?"NOT BETWEEN":"BETWEEN"),r&&-1!==r.indexOf(",")&&(c="NOT LIKE"===c?"NOT IN":"IN"),e&&i.push({key:this.checkAliases(e),operator:c,value:r,logic:a||"AND"}),l&&-1!==l.indexOf("#")){const e=l.replace(/#|\(|\)/g,"");i.push(t[parseInt(e)])}else if(this.allowGlobalSearch&&l&&-1===l.indexOf("#")){let e="plain_+";l.startsWith("-")&&(e="plain_-"),i.push({operator:e,value:l.replace(/\+|\-/gm,""),logic:a||"AND"})}}return i},this.aliases=s&&s.aliases||{},this.allowGlobalSearch=s&&s.allowGlobalSearch||!1}checkAliases(e){return this.aliases?this.aliases[e]?this.aliases[e]:this.aliases["*"]?this.aliases["*"].replaceAll("{{key}}",e):e:e}}class o{constructor(e,t="pg"){this.table=e,this.dialect=t}parse(e){let t="",r=[];for(let s of e)if(Array.isArray(s)){const{query:e,bindings:n}=this.parse(s);t+=`(${e})`,r=[...r,...n]}else if("object"==typeof s){const{query:e,bindings:n}=this.convertCondition(s);t+=e,r=[...r,...n]}else console.warn("Unknown type detected in qry");return t=t.replace(/( AND | OR )$/gm,""),{query:t,bindings:r}}convertCondition(e){if(!e.key){if("pg"!==this.dialect)return console.warn("Only PostgreSQL supports global searching"),"";let t="";return"plain_-"===e.operator&&(t="NOT"),{query:`${t} to_tsvector(?::text) @@ to_tsquery(?) ${n}`,bindings:[this.table,s]}}let{key:t,operator:r,value:s,logic:n}=e,i="?",o=[s.replaceAll('"',"")];return"BETWEEN"!==r&&"NOT BETWEEN"!==r||(o=s.replace(/\[|\]/gm,""),o=o.split(" TO "),i="? AND ?"),"IN"!==r&&"NOT IN"!==r||(o=[s.split(",")]),{query:`${t} ${r} ${i} ${n} `,bindings:o}}}class l extends o{toKnex(e,t){const r=this.parse(t);return e.whereRaw(r.query,r.bindings)}}export{i as FQLParser,l as KnexParser,o as SQLParser};
//# sourceMappingURL=parser.modern.js.map
