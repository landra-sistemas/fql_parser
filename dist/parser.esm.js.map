{"version":3,"file":"parser.esm.js","sources":["../src/FQLParser.mjs","../src/sql/SQLParser.mjs","../src/sql/KnexParser.mjs"],"sourcesContent":["import XRegExp from \"xregexp\";\r\nimport lodash from \"lodash\";\r\n\r\nexport default class FQLParser {\r\n\r\n    LIKE = \"LIKE\";\r\n\r\n    constructor(options) {\r\n        this.aliases = (options && options.aliases) || {};\r\n        this.allowGlobalSearch = (options && options.allowGlobalSearch) || false;\r\n\r\n        if (options && options.caseInsensitive) {\r\n            this.LIKE = \"ILIKE\";\r\n        }\r\n    }\r\n    /**\r\n     * Convierte un string 'key:value' en array de objetos con las siguientes opciones:\r\n     * \r\n     * - Objeto: { //Condición Básica\r\n     *  \"key\": \"\",\r\n     *  \"operator\": \"LIKE|NOT LIKE|>|<|BETWEEN\", //Default LIKE\r\n     *  \"value\": \"\",\r\n     *  \"logic\": \"OR|AND\" //Default AND\r\n     * }\r\n     * \r\n     * - Array: Agrupación de condiciones, extraída de un (). Dentro del array llevará otros array o objetos condición\r\n     * \r\n     * @param {*} str \r\n     * @returns \r\n     */\r\n    parse = (str) => {\r\n        let parsedElm = [];\r\n        let workStr = str;\r\n        const parentheses = this.splitPatentheses(str);\r\n\r\n        if (!lodash.isEmpty(parentheses)) {\r\n            for (const elm in parentheses) {\r\n                //Reemplazar el la query original cada elemento\r\n                workStr = workStr.replace(`${parentheses[elm]}`, `#${elm}`);\r\n                parsedElm.push(this.parse(parentheses[elm]));\r\n            }\r\n\r\n        }\r\n        // console.log(workStr);\r\n\r\n        return this.parseQS(workStr, parsedElm);\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * Extrae los bloques entre parentesis (solo un nivel).\r\n     * \r\n     * @param {*} str \r\n     * @returns \r\n     */\r\n    splitPatentheses = (str) => {\r\n        const test = XRegExp.matchRecursive(str, '\\\\(', '\\\\)', 'g');\r\n        return test;\r\n    }\r\n\r\n\r\n    /**\r\n     * Aplica una expresión regular para extraer los parámetros de búsqueda:\r\n     * - key: columna\r\n     * - operator: operador búsqueda\r\n     * - value: valor a buscar\r\n     * - logic: operador logico a utilizar\r\n     * - plain: parametro plano adicional (ejemplo +test o -asdfasdf). Necesario activar allowGlobalSearch\r\n     * @param {*} str \r\n     * @param {*} subgroups \r\n     * @returns \r\n     */\r\n    parseQS = (str, subgroups) => {\r\n        const regex = /((?<key>[^\\s|^:|^!:|^>:|^<:]+)(?<operator>:|!:|>:|<:)(?<value>[^\\s|\"|\\[]+|\".*?\"|\\[.*?\\]))? ?(?<logic>OR|AND)? ?(?<plain>[\\+|\\-|\\(#][^\\s]+|)? ?/gm;\r\n        let m;\r\n\r\n        let data = [];\r\n        while ((m = regex.exec(str)) !== null) {\r\n            // This is necessary to avoid infinite loops with zero-width matches\r\n            if (m.index === regex.lastIndex) {\r\n                regex.lastIndex++;\r\n            }\r\n            if (m === null) {\r\n                continue;\r\n            }\r\n            let { key, value, operator, plain, logic } = m.groups;\r\n\r\n            if (!operator) {\r\n                operator = \":\";\r\n            }\r\n\r\n            let type = this.LIKE;\r\n            switch (operator) {\r\n                case \":\":\r\n                default:\r\n                    type = this.LIKE;\r\n                    break;\r\n                case \"!:\":\r\n                    type = `NOT ${this.LIKE}`;\r\n                    break;\r\n                case \">:\":\r\n                    type = \">\";\r\n                    break;\r\n                case \"<:\":\r\n                    type = \"<\";\r\n                    break;\r\n            }\r\n            //Los corchetes marcan rangos con lo que si se detecta se cambia el tipo LIKE a BETWEEN\r\n            if (value && value.match(/\\[.*?\\]/)) {\r\n                type = type === `NOT ${this.LIKE}` ? \"NOT BETWEEN\" : \"BETWEEN\";\r\n            }\r\n            //Las comas implican varios valores con lo que si se detectan se cambia el tipo LIKE a IN\r\n            if (value && value.indexOf(',') !== -1) {\r\n                type = type === `NOT ${this.LIKE}` ? \"NOT IN\" : \"IN\";\r\n            }\r\n\r\n            if (key) {\r\n                data.push({\r\n                    key: this.checkAliases(key),\r\n                    operator: type,\r\n                    value: this.parseValue(value),\r\n                    logic: logic || \"AND\"\r\n                });\r\n            }\r\n            // Gestion para añadir los indices de los subgrupos\r\n            if (plain && plain.indexOf('#') !== -1) {\r\n                const index = plain.replace(/#|\\(|\\)/g, '');\r\n                data.push(subgroups[parseInt(index)]);\r\n            } else if (this.allowGlobalSearch && plain && plain.indexOf('#') === -1) {\r\n                // Añadir las busquedas plain en caso de estar activadas.\r\n                let op = \"plain_+\";\r\n                if (plain.startsWith('-')) {\r\n                    op = \"plain_-\";\r\n                }\r\n                data.push({\r\n                    operator: op,\r\n                    value: this.parseValue(plain.replace(/\\+|\\-/gm, '')),\r\n                    logic: logic || \"AND\"\r\n                });\r\n            }\r\n        }\r\n        return data;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * \r\n     * @param key \r\n     * @returns \r\n     */\r\n    checkAliases(key) {\r\n        if (!this.aliases) {\r\n            return key;\r\n        }\r\n        if (this.aliases[key]) {\r\n            return this.aliases[key].replaceAll(\"{{key}}\", key);\r\n        }\r\n        if (this.aliases['*']) {\r\n            return this.aliases['*'].replaceAll(\"{{key}}\", key);\r\n        }\r\n        return key;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param value \r\n     * @returns \r\n     */\r\n    parseValue(value) {\r\n        //TODO improve\r\n        return value.replaceAll(/\"|\\?/g, '').replaceAll('*', '%');\r\n    }\r\n}\r\n","export default class SQLParser {\r\n\r\n    constructor(table, dialect = \"pg\") {\r\n        this.table = table;\r\n        this.dialect = dialect;\r\n    }\r\n\r\n    /**\r\n     * Converte una lista de condiciones generada por el FQLParser en una condición String.\r\n     * \r\n     * Esta clase sirve como base para su extensión aplicando las conversiones necesarias en función del lenguaje a utilizar.\r\n     * \r\n     * @param {Array} object\r\n     */\r\n    parse(object) {\r\n        let query = \"\";\r\n        let bindings = [];\r\n        for (let element of object) {\r\n            if (Array.isArray(element)) {\r\n                const { query: subqry, bindings: subbind } = this.parse(element);\r\n                query += `(${subqry})`;\r\n                bindings = [...bindings, ...subbind];\r\n            } else if (typeof element === 'object') {\r\n                const { query: condition, bindings: bind } = this.convertCondition(element);\r\n                query += condition;\r\n                bindings = [...bindings, ...bind];\r\n            } else {\r\n                console.warn('Unknown type detected in qry');\r\n            }\r\n        }\r\n        query = query.replace(/( AND | OR )$/gm, \"\");\r\n        return { query, bindings }; //Quitar condicion final\r\n    }\r\n\r\n    /**\r\n     * Metodo base a ser extendido por los parsers para realizar las conversiones\r\n     * \r\n     * @param {object} condition \r\n     */\r\n    convertCondition(condition) {\r\n        let { key, operator, value, logic } = condition;\r\n        if (!key) {\r\n            if (this.dialect !== \"pg\") {\r\n                console.warn('Only PostgreSQL supports global searching');\r\n                return \"\";\r\n            }\r\n\r\n            let op = \"\";\r\n            if (operator === \"plain_-\") {\r\n                op = \"NOT\";\r\n            }\r\n            return { query: `${op} to_tsvector(${this.table}::text) @@ to_tsquery(?) ${logic} `, bindings: [value] }\r\n        }\r\n\r\n\r\n        let binding = \"?\";\r\n        let parsedValue = [value]; //Eliminar las dobles comillas\r\n\r\n        if (operator === \"BETWEEN\" || operator === \"NOT BETWEEN\") {\r\n            parsedValue = value.replace(/\\[|\\]/gm, '');\r\n            parsedValue = parsedValue.split(' TO ');\r\n            binding = \"? AND ?\";\r\n        }\r\n        if (operator === \"IN\" || operator === \"NOT IN\") {\r\n            parsedValue = [value.split(',')];\r\n        }\r\n\r\n        return { query: `${key} ${operator} ${binding} ${logic} `, bindings: parsedValue }\r\n    }\r\n\r\n\r\n}","import SQLParser from \"./SQLParser.mjs\";\r\n\r\nexport default class KnexParser extends SQLParser {\r\n\r\n    /**\r\n     * \r\n     * @param {Knex} builder \r\n     * @param {object} object \r\n     */\r\n    toKnex(builder, object) {\r\n        const parsed = this.parse(object);\r\n        return builder.whereRaw(parsed.query, parsed.bindings);\r\n    }\r\n}"],"names":["FQLParser","options","_this","this","LIKE","parse","str","parsedElm","workStr","parentheses","splitPatentheses","lodash","isEmpty","elm","replace","push","parseQS","XRegExp","matchRecursive","subgroups","m","regex","_wrapRegExp","key","operator","value","logic","plain","data","exec","index","lastIndex","_m$groups","groups","type","match","indexOf","checkAliases","parseValue","parseInt","allowGlobalSearch","op","startsWith","aliases","caseInsensitive","replaceAll","SQLParser","table","dialect","object","_step","query","bindings","_iterator","_createForOfIteratorHelperLoose","done","element","Array","isArray","_this$parse","concat","_this$convertConditio","convertCondition","console","warn","condition","binding","parsedValue","split","KnexParser","toKnex","builder","parsed","whereRaw"],"mappings":"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"}